%import diskio
%import cave
%import objects         ; this module is autogenerated by a script


screen {
    word scrollx
    word scrolly
    bool scrolling_into_view_x = false
    bool scrolling_into_view_y = false

    sub set_scroll_pos(uword sx, uword sy) {
        scrollx = sx as word
        scrolly = sy as word
    }

    ubyte old_vera_displaymode
    sub disable() {
        old_vera_displaymode = cx16.VERA_DC_VIDEO
        cx16.VERA_CTRL = 0
        cx16.VERA_DC_VIDEO &= %10001111
    }

    sub enable() {
        cx16.VERA_CTRL = 0
        cx16.VERA_DC_VIDEO = old_vera_displaymode
    }

    sub update() {
        ; set the tiles in video ram for the visible cells.
        ; cx16.vpoke(1,$fa00,$0f)
        ubyte row_offset = lsb(scrolly/16)
        ubyte col_offset = lsb(scrollx/16)
        ubyte @zp row
        for row in row_offset to row_offset+cave.VISIBLE_CELLS_V {
            cx16.vaddr(1, $b000 + row*$0080 + col_offset*2, 0, 1)
            uword cells_offset = row*cave.MAX_CAVE_WIDTH + col_offset
            uword @requirezp @shared cell_ptr = cave.cells + cells_offset
            uword @requirezp @shared attr_ptr = cave.cell_attributes + cells_offset
            %asm {{
                phx
                ldy  #0
_loop           lda  (p8v_attr_ptr),y
                and  #p8b_cave.p8c_ATTR_COVERED_FLAG
                beq  +
                ldx  #p8b_objects.p8c_covered
                bra  ++
+               lda  (p8v_cell_ptr),y
                tax
+               lda  p8b_objects.p8v_tile_lo,x
                clc
                adc  p8b_objects.p8v_anim_frame,x
                sta  cx16.VERA_DATA0
                lda  p8b_objects.p8v_tile_hi,x
                adc  p8b_objects.p8v_palette_offsets_preshifted,x
                sta  cx16.VERA_DATA0
                iny
                cpy  #p8b_cave.p8c_VISIBLE_CELLS_H+1
                bne  _loop
                plx
            }}
        }
        ; cx16.vpoke(1,$fa00,$00)
        screen.update_animations()
        if cave.scroll_enabled
            screen.update_scrollpos()
    }

    sub update_scrollpos() {
        ; try to recenter rockford in the visible screen
        word target_scrollx = (cave.player_x as word - cave.VISIBLE_CELLS_H/2) * 16
        word target_scrolly = (cave.player_y as word - cave.VISIBLE_CELLS_V/2) * 16
        word dx = target_scrollx - scrollx
        word dy = target_scrolly - scrolly
        if not scrolling_into_view_x {
            if abs(dx) < cave.VISIBLE_CELLS_H/4*16
                dx = 0
            else
                scrolling_into_view_x = true
        }
        if not scrolling_into_view_y {
            if abs(dy) < cave.VISIBLE_CELLS_V/4*16
                dy = 0
            else
                scrolling_into_view_y = true
        }

        scrolling_into_view_x = dx!=0
        scrolling_into_view_y = dy!=0
        if scrolling_into_view_x {
            dx >>= 5
            if dx==0
                scrollx++
            else
                scrollx += dx
        }
        if scrolling_into_view_y {
            dy >>= 5
            if dy==0
                scrolly++
            else
                scrolly += dy
        }
        scrollx = clamp(scrollx, 0, (cave.MAX_CAVE_WIDTH-cave.VISIBLE_CELLS_H)*16 as word)
        scrolly = clamp(scrolly, 0, (cave.MAX_CAVE_HEIGHT-cave.VISIBLE_CELLS_V)*16)
    }

    sub titlescreen() {
        ; 320x240 bitmap mode 4bpp (16 colors)
        cx16.VERA_CTRL = 0
        cx16.VERA_DC_BORDER = 0
        cx16.VERA_DC_VIDEO = cx16.VERA_DC_VIDEO & %10001111      ; no layers visible
        cx16.VERA_DC_HSCALE = 64
        cx16.VERA_DC_VSCALE = 64
        cx16.VERA_L0_CONFIG = %00000110
        cx16.VERA_L0_TILEBASE = 0

        void diskio.vload_raw("titlescreen.bin", 0, $0000)
        void diskio.vload_raw("titlescreen.pal", 1, $fa00)
        cx16.VERA_DC_VIDEO = cx16.VERA_DC_VIDEO | %00010000       ; layer 0 active
    }

    sub load_tiles(ubyte tileset) {
        load_game_tiles(tileset)
        void diskio.vload_raw("font.bin", 1, $e000)
        ; fixup the palette for the HUD text font (entries $f0-$ff)
        cx16.vpoke(1,$fa00+$f0*2,$00)
        cx16.vpoke(1,$fa00+$f0*2+1,$00)
        cx16.vpoke(1,$fa00+$f1*2,$24)
        cx16.vpoke(1,$fa00+$f1*2+1,$05)
        cx16.vpoke(1,$fa00+$f2*2,$ff)
        cx16.vpoke(1,$fa00+$f2*2+1,$0f)
        cx16.vpoke(1,$fa00+$f2*3,$f0)
        cx16.vpoke(1,$fa00+$f2*3+1,$ff)

        void diskio.vload_raw("bgsprite.bin", 1, $f000)
        void diskio.vload_raw("bgsprite.pal", 1, $fa00+14*16*2)
        void diskio.vload_raw("logosprite.bin", 1, $d000)
        void diskio.vload_raw("titlescreen.pal", 1, $fa00+13*16*2)
    }

    sub load_game_tiles(ubyte tileset) {
        str tiles_file = "tiles0.bin"
        str palette_file = "tiles0.pal"

        tiles_file[5] = tileset + '0'
        palette_file[5] = tileset + '0'

        void diskio.vload_raw(tiles_file, 0, $0000)
        void diskio.vload_raw(palette_file, 1, $fa00)

        ; patch up some tile data differences
        ; TODO this just overwrites whatever is in the catalog.ini ....
        when tileset {
            1 -> {
                ; classic tiles
                objects.anim_frame[objects.covered] = objects.anim_delay[objects.covered] = 0
                objects.anim_sizes[objects.covered] = 8
                objects.anim_speeds[objects.covered] = 2
                objects.anim_speeds[objects.firefly] = 3
                objects.anim_speeds[objects.altfirefly] = 3
            }
            2 -> {
                ; updated tiles
                objects.anim_frame[objects.covered] = objects.anim_delay[objects.covered] = 0
                objects.anim_sizes[objects.covered] = 6
                objects.anim_speeds[objects.covered] = 5
                objects.anim_speeds[objects.firefly] = 5
                objects.anim_speeds[objects.altfirefly] = 5
            }
        }
    }

    sub update_animations() {
        ; increase anim delay counter of all animate objects
        ; once they reach their target, set it to 0 which will trigger the next animation tile in the sequence
        ; cx16.vpoke(1,$fa00,$f0)
        ubyte idx
        for idx in 0 to objects.NUM_OBJECTS-1 {
            if objects.anim_speeds[idx]!=0 {
                cx16.r0L = objects.anim_delay[idx]
                cx16.r0L++
                if cx16.r0L == objects.anim_speeds[idx] {
                    cx16.r0L = 0
                    cx16.r1L = objects.anim_frame[idx]
                    cx16.r1L++
                    if cx16.r1L == objects.anim_sizes[idx] {
                        if objects.attributes[idx] & objects.ATTRF_LOOPINGANIM !=0
                            cx16.r1L = 0
                        else
                            cx16.r1L--
                    }
                    objects.anim_frame[idx] = cx16.r1L
                }
                objects.anim_delay[idx] = cx16.r0L
            }
        }
        ; cx16.vpoke(1,$fa00,$00)
    }

    sub set_tiles_screenmode() {
        ; video setup:
        ; layer 0 = tile layer for the cave itself.
        ;           320x240 pixels, 4bpp (16 colors) 16x16 tiles.
        ;           tile map: 64x32 tiles at $1B000.
        ; layer 1 = tile layer for the text/HUD/score/time/etc.
        ;           320x240 pixels, 4bpp (16 colors) 16x16 tiles.
        ;           tile map: 64x32 tiles at $1C000.
        ;           uses font data at $1E000
        ; sprites background layer.

        ; pre-fill screen with space tiles
        cx16.vaddr(1, $b000, 0, 1)
        ubyte space_tile = objects.tile_lo[objects.space]
        repeat 64*32 {
            cx16.VERA_DATA0 = space_tile
            cx16.VERA_DATA0 = 0
        }
        hud_clear()

        cx16.VERA_CTRL = 0
        cx16.VERA_DC_BORDER = 0
        cx16.VERA_DC_VIDEO = cx16.VERA_DC_VIDEO & $0f | %01110000       ; layer 0 and 1 active, and sprites
        cx16.VERA_DC_HSCALE = 64
        cx16.VERA_DC_VSCALE = 64
        cx16.VERA_L0_CONFIG = %00010010                 ; 64x32 tiles, 4bpp
        cx16.VERA_L0_MAPBASE = ($1B000 >> 9) as ubyte
        cx16.VERA_L0_TILEBASE = %00000011               ; 16x16 pixel tiles
        cx16.VERA_L1_CONFIG = %00010001                 ; 64x32 tiles, 2bpp
        cx16.VERA_L1_MAPBASE = ($1C000 >> 9) as ubyte
        cx16.VERA_L1_TILEBASE = ($1E000 >>9) as ubyte | %00000000               ; 8x8 pixel tiles
    }

    sub hud_clear() {
        cx16.vaddr(1, $c000, 0, 1)
        repeat 64*32 {
            cx16.VERA_DATA0 = 32
            cx16.VERA_DATA0 = $f0
        }
    }

    sub hud_texts(uword texts_specs, ubyte amount) {
        repeat amount {
            cx16.r0 = peekw(texts_specs)
            hud_text(cx16.r0H, cx16.r0L, peekw(texts_specs+2))
            texts_specs += 4
        }
    }

    sub hud_text(ubyte col, ubyte row, uword text_ptr) {
        uword offset = (row as uword) * 128 + col*2
        cx16.vaddr(1, $c000 + offset, 0, 1)
        repeat {
            cx16.r0L = @(text_ptr)
            if_z
                return
            cx16.VERA_DATA0 = cx16.r0L
            cx16.VERA_DATA0 = $f0  ; 'color'
            text_ptr++
        }
    }

    sub hud_wrap_text(ubyte col, ubyte row, ubyte maxwidth, uword text_ptr) {
        ubyte line_width
        row--
        new_line()
        repeat {
            ubyte word_length = next_word_length(text_ptr)
            if_z
                return
            repeat word_length {
                cx16.VERA_DATA0 = @(text_ptr)
                cx16.VERA_DATA0 = $f0 ; 'color'
                text_ptr++
                line_width++
            }
            cx16.VERA_DATA0 = ' '
            cx16.VERA_DATA0 = $f0 ; 'color'
            line_width++

            if @(text_ptr)==0
                return
            text_ptr++

            if line_width>maxwidth
                new_line()
        }

        sub new_line() {
            row++
            uword offset = (row as uword) * 128 + col*2
            cx16.vaddr(1, $c000 + offset, 0, 1)
            line_width = 0
        }

        sub next_word_length(uword txt) -> ubyte {
            ubyte length=0
            repeat {
                if @(txt)==0 or @(txt)==' '
                    return length
                length++
                txt++
            }
        }
    }

    sub hud_update() {
        const ubyte xpos = 8
        uword[] @nosplit hud_elements = [
            mkword(xpos+1, 1), "\x8e",      ; diamond symbol
            mkword(xpos+6, 1), "/",
            mkword(xpos+12, 1), "\x88",     ; rockford symbol
            mkword(xpos+19, 1), "\x8f",     ; clock symbol
        ]
        screen.hud_texts(hud_elements, len(hud_elements)/2)

        screen.hud_text(xpos+3, 1, conv.str_ub0(cave.num_diamonds))
        screen.hud_text(xpos+7, 1, conv.str_ub0(cave.diamonds_needed))
        screen.hud_text(xpos+14, 1, conv.str_ub0(cave.num_lives))
        screen.hud_text(xpos+21, 1, conv.str_ub0(cave.time_left_secs))
        screen.hud_text(xpos+26, 1, conv.str_uw0(cave.score))
    }

    sub show_cave_title(bool with_description) {
        const ubyte xpos = 3
        const ubyte ypos = 11
        screen.hud_text(xpos+4, ypos, "cave:")
        screen.hud_text(xpos+10, ypos, cave.name)
        if with_description
            screen.hud_wrap_text(xpos, ypos+3, 25, cave.description)
    }

    sub show_logo_image(bool visible) {
        ; the logo consists of two 64*64 sprites 4bpp

        cx16.VERA_CTRL = 0
        if visible {
            cx16.vaddr(1, $fc00, 0, 1)
            uword spr_xpos = 160-64
            uword spr_data = $1d000 >> 5
            repeat 2 {
                cx16.VERA_DATA0 = lsb(spr_data)
                cx16.VERA_DATA0 = msb(spr_data)
                cx16.VERA_DATA0 = lsb(spr_xpos)
                cx16.VERA_DATA0 = msb(spr_xpos)
                cx16.VERA_DATA0 = 44
                cx16.VERA_DATA0 = 0
                cx16.VERA_DATA0 = %00001100
                cx16.VERA_DATA0 = %11110000 | 13        ; palette offset 13 (14 is used by the stars backdrop, 15 by the text)
                spr_xpos += 64
                spr_data += 64
            }
            cx16.VERA_DC_VIDEO |= %01000000
        }
        else
            cx16.VERA_DC_VIDEO &= %10111111
    }

    sub show_background_sprite_layer() {
        ; background sprite layer: repeat a big sprite a couple of times across the background.
        cx16.vaddr(1, $fc00, 0, 1)
        ubyte spr_ypos = 0
        repeat 4 {
            ubyte spr_xpos = 8
            repeat 4 {
                cx16.VERA_DATA0 = lsb($1f000 >> 5)
                cx16.VERA_DATA0 = lsb($1f000 >> 13)
                cx16.VERA_DATA0 = spr_xpos
                cx16.VERA_DATA0 = 0
                cx16.VERA_DATA0 = spr_ypos
                cx16.VERA_DATA0 = 0
                cx16.VERA_DATA0 = %00000100
                cx16.VERA_DATA0 = %11110000 | 14
                spr_xpos += 80
                spr_ypos += 8
            }
            spr_ypos += 80-32
        }

        cx16.VERA_DC_VIDEO |= %01000000
    }

    bool white_flash
    ubyte[16*4] palette_save

    sub flash_white(bool white) {
        white_flash = white
        ubyte idx=0
        uword pal = $fa00
        if white {
            repeat 16 {
                palette_save[idx] = cx16.vpeek(1,pal)
                idx++
                cx16.vpoke(1,pal,$ff)
                pal++
                palette_save[idx] = cx16.vpeek(1,pal)
                idx++
                cx16.vpoke(1,pal,$0f)
                pal++
                palette_save[idx] = cx16.vpeek(1,pal)
                idx++
                cx16.vpoke(1,pal,$ff)
                pal++
                palette_save[idx] = cx16.vpeek(1,pal)
                idx++
                cx16.vpoke(1,pal,$0f)
                pal+=29
            }
        } else {
            repeat 16 {
                cx16.vpoke(1,pal,palette_save[idx])
                idx++
                pal++
                cx16.vpoke(1,pal,palette_save[idx])
                idx++
                pal++
                cx16.vpoke(1,pal,palette_save[idx])
                idx++
                pal++
                cx16.vpoke(1,pal,palette_save[idx])
                idx++
                pal+=29
            }
        }
    }

    uword[16] orig_covertile_colors
    bool already_dimmed
    sub dim_covertile_color(bool dim) {
        ; This makes the cover tile colors darker (or resets them back to the originals),
        ; it is used on the title screens to make the text more readable.

        if dim and already_dimmed
            return      ; don't dim twice

        uword palette_idx = $fa00 + objects.palette_offsets_preshifted[objects.covered]*$0002

        if not already_dimmed {
            ; backup the original covertile color entries
            cx16.vaddr(1, palette_idx, 0, 1)
            for cx16.r0L in 0 to 15 {
                cx16.r1 = mkword(cx16.VERA_DATA0, cx16.VERA_DATA0)
                orig_covertile_colors[cx16.r0L] = cx16.r1
            }
        }

        cx16.vaddr(1, palette_idx, 0, 1)
        if dim {
            for cx16.r0L in 0 to 15 {
                cx16.r1 = orig_covertile_colors[cx16.r0L]
                cx16.VERA_DATA0 = (lsb(cx16.r1) >> 1) & %01110111
                cx16.VERA_DATA0 = msb(cx16.r1)>>1
            }
        } else {
            for cx16.r0L in 0 to 15 {
                cx16.r1 = orig_covertile_colors[cx16.r0L]
                cx16.VERA_DATA0 = lsb(cx16.r1)
                cx16.VERA_DATA0 = msb(cx16.r1)
            }
        }
        already_dimmed = dim
    }
}
