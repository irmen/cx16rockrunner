%import conv
%import diskio
%import psg
%import objects         ; this module is autogenerated by a script
%import cave
%import bd1demo
%import bdcff
%import sounds
%import highscore

main {
    ubyte chosen_level
    ubyte chosen_difficulty
    ubyte game_state
    bool demo_requested

    str BD1_CAVESET_FILE = "boulderdash01.bd"
    const ubyte STATE_CAVETITLE = 1
    const ubyte STATE_TITLE_MENU = 2
    const ubyte STATE_UNCOVERING = 3
    const ubyte STATE_PLAYING = 4
    const ubyte STATE_GAMEOVER = 5
    const ubyte STATE_DEMO = 6
    const ubyte STATE_SHOWING_HISCORE = 7
    const ubyte STATE_ENTER_NAME = 8
    const ubyte STATE_SELECT_CAVESET = 9
    const uword HISCORE_WAIT_TIME = 60 * 12
    const uword HISCORE_DISPLAY_TIME = 60 * 6
    const uword INSTRUCTIONS_DISPLAY_TIME = 60 * 10
    const uword DEMO_WAIT_TIME = 60 * 21 - HISCORE_DISPLAY_TIME

    const bool quicklaunch_mode = false           ; set to TRUE to quickly enter game (loads 0-test.bd caveset)
    const ubyte quicklaunch_start_cave = 'b'
    const ubyte quicklaunch_joystick = 0
    const ubyte quicklaunch_cavespeed = 8


    sub start() {
;        repeat {
;            ubyte k = cbm.GETIN()
;            if k {
;                txt.print_ub(k)
;                txt.spc()
;            }
;        }

        clear_abort_error()
        joystick.active_joystick = 0
        interrupts.ram_bank = cx16.getrambank()
        music.init()
        if not quicklaunch_mode
            screen.titlescreen()
        sys.set_irq(&interrupts.handler)
        music.playback_enabled = not quicklaunch_mode

        if quicklaunch_mode {
            void bdcff.load_caveset("0-test.bd")
            void bdcff.parse_caveset()
        } else {
            if not bdcff.load_caveset(BD1_CAVESET_FILE) or not bdcff.parse_caveset() {
                ; caveset load error
                error_abort($80)
            }
            sys.wait(200)
        }

        cave.init()
        highscore.load(bdcff.caveset_filename)
        screen.set_tiles_screenmode()
        screen.disable()
        screen.load_tiles()
        activate_title_menu_state()
        screen.enable()
        ubyte title_timer
        uword start_demo_timer = DEMO_WAIT_TIME
        uword start_hiscore_timer = HISCORE_WAIT_TIME
        uword display_hiscore_timer

        repeat {
            ; the game loop, executed every frame.
            interrupts.waitvsync()
            screen.update()

            when game_state {
                STATE_TITLE_MENU -> {
                    choose_level()
                    start_demo_timer--
                    if start_demo_timer==0 {
                        start_demo_timer = DEMO_WAIT_TIME
                        if bdcff.caveset_filename == BD1_CAVESET_FILE
                            play_demo()
                    }
                    start_hiscore_timer--
                    if start_hiscore_timer==0 {
                        start_hiscore_timer = HISCORE_WAIT_TIME
                        show_hiscore()
                    }
                }
                STATE_CAVETITLE -> {
                    title_timer--
                    if_z {
                        screen.set_scroll_pos(0, 0)     ; not random?
                        screen.hud_clear()
                        if demo_requested {
                            screen.hud_text(9,10,"\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88")
                            screen.hud_text(9,11,"\x8e                    \x8d")
                            screen.hud_text(9,12,"\x8d    Rock  Runner    \x8e")
                            screen.hud_text(9,13,"\x8e                    \x8d")
                            screen.hud_text(9,14,"\x8d       Demo !       \x8e")
                            screen.hud_text(9,15,"\x8e                    \x8d")
                            screen.hud_text(9,16,"\x8d press ESC to abort \x8e")
                            screen.hud_text(9,17,"\x8e                    \x8d")
                            screen.hud_text(9,18,"\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88")
                        }
                        music.playback_enabled = false
                        game_state = STATE_UNCOVERING
                    }
                }
                STATE_UNCOVERING -> {
                    if quicklaunch_mode
                        cave.uncover_all()
                    cave.uncover_more()
                    if not cave.covered {
                        while cbm.GETIN2()!=0 { /* clear keyboard buffer */ }
                        cave.scroll_enabled = cave.width>cave.VISIBLE_CELLS_H or cave.height>cave.VISIBLE_CELLS_V
                        interrupts.cavescan_frame = 0
                        if demo_requested
                            game_state = STATE_DEMO
                        else
                            game_state = STATE_PLAYING
                    }
                }
                STATE_PLAYING -> {
                    ubyte action = cave.scan()
                    if interrupts.vsync_counter % 3 == 0
                        screen.hud_update()
                    when action {
                        cave.ACTION_GAMEOVER -> game_state = STATE_GAMEOVER
                        cave.ACTION_RESTARTLEVEL -> {
                            if cave.intermission {
                                ; intermissions are bonus levels and you have only one try at them
                                next_level()
                            } else {
                                bdcff.parse_cave(chosen_level, chosen_difficulty)
                                cave.cover_all()
                                cave.restart_level()
                                game_state = STATE_UNCOVERING
                            }
                        }
                        cave.ACTION_NEXTLEVEL -> {
                            next_level()
                        }
                    }
                }
                STATE_DEMO -> {
                    if cave.scan() != cave.ACTION_NOTHING {
                        activate_title_menu_state()
                    }
                }
                STATE_SHOWING_HISCORE -> {
                    display_hiscore_timer--
                    if display_hiscore_timer==0 or cbm.GETIN2()==27 {
                        activate_title_menu_state()
                    }
                }
                STATE_GAMEOVER -> {
                    if highscore.highscore_pos(cave.score)!=0
                        activate_highscore_enter_name()
                    else
                        show_hiscore()
                }
                STATE_ENTER_NAME -> {
                    if highscore.enter_name() {
                        highscore.record_score(bdcff.caveset_filename, cave.score, highscore.name_input)
                        show_hiscore()
                    } else
                        screen.hud_text(24,14,highscore.name_input)
                }
                STATE_SELECT_CAVESET -> {
                    select_caveset()
                }
            }
        }
    }

    sub clear_abort_error() {
        ; make sure no error value is stored initially
        @($0400) = 0
        @($0401) = 0
    }

    sub error_abort(ubyte errorcode) {
        ; stores the error code at $0400 and $0401 so you can tell what it was after the monitor brk or reset.
        @($0400) = errorcode
        @($0401) = errorcode
        %asm {{
            brk
        }}
        sys.reset_system()
    }

    sub next_level() {
        chosen_level++
        if chosen_level > bdcff.num_caves {
            chosen_level = 1
            chosen_difficulty = min(5, chosen_difficulty+1)
        }
        bdcff.parse_cave(chosen_level, chosen_difficulty)
        start_loaded_level()
    }

    sub activate_title_menu_state() {
        game_state = STATE_TITLE_MENU
        chosen_difficulty = 1
        chosen_level = 1
        main.choose_level.update_hud_choices_text()
        demo_requested = false
        screen.hud_clear()
        screen.show_logo_image(false)
        cave.cover_all()
        screen.dim_covertile_color(true)
        if not music.playback_enabled {
            music.init()
            music.playback_enabled = true
        }
        while cbm.GETIN2()!=0 { /* clear keyboard buffer */ }
    }

    sub choose_level() {
        ubyte letter
        bool joy_start = false
        for joystick.active_joystick in 0 to 4 {
            joystick.scan()
            if joystick.start {
                joy_start = true
                break
            }
        }

        str cave_letter_str     = "A-T: select start cave [A]"
        str cave_difficulty_str = "1-5: select difficulty [1]"
        letter = cbm.GETIN2()

        if quicklaunch_mode
            letter = quicklaunch_start_cave

        if letter!=0 {
            main.start.start_demo_timer = DEMO_WAIT_TIME
            main.start.start_hiscore_timer = HISCORE_WAIT_TIME
        }
        if letter==13 or joy_start {
            ; start the game!
            bdcff.parse_cave(chosen_level, chosen_difficulty)
            start_new_game()
            start_loaded_level()
            return
        }
        else if letter>='a' and letter <= 't' {
            ; letter - select start cave
            cx16.r0L = letter - 'a' + 1
            if cx16.r0L <= bdcff.num_caves {
                chosen_level = cx16.r0L
                update_hud_choices_text()
                bdcff.parse_cave(chosen_level, chosen_difficulty)
                cave.cover_all()
                screen.hud_clear()
                ; Don't show the cave title anymore it falls below the game's logo graphics.
                ; screen.show_cave_title(false)
                if quicklaunch_mode {
                    start_new_game()
                    start_loaded_level()
                    joystick.active_joystick=quicklaunch_joystick
                    cave.cave_speed = quicklaunch_cavespeed
                    return
                }
            }
            while cbm.GETIN2()!=0 { /* clear keyboard buffer */ }
        }
        else if letter>='1' and letter <= '5' {
            ; digit - select difficulty
            cx16.r0L = letter-'0'
            if cx16.r0L <= bdcff.num_difficulty_levels {
                chosen_difficulty = cx16.r0L
                update_hud_choices_text()
            }
        }
        else if letter==133 {
            ; F1 - load different caveset
            activate_select_caveset('*')
            return
        }
        else if letter==137 {
            ; F2 - play demo
            play_demo()
            return
        }
        else if letter==134 {
            ; F3 - hall of fame
            show_hiscore()
            return
        }
        else if letter==138 {
            ; F4 - instructions
            show_instructions()
            return
        }
        screen.hud_text(4,2,"\x8e\x8e\x8e\x8e   Rock  Runner   v1.3a \x8e\x8e\x8e\x8e")         ; VERSION NUMBER is here (1.3a)
        screen.hud_text(4,4,"by DesertFish. Written in Prog8")

        ; what caveset is loaded
        screen.hud_text(4,6,"Caveset: ")
        screen.hud_text(13, 6, bdcff.caveset_filename)
        screen.hud_text(6, 7, bdcff.caveset_name)
        screen.hud_text(6, 8, bdcff.caveset_author)

        ; menu
        screen.hud_text(7,19,cave_letter_str)
        screen.hud_text(7,20,cave_difficulty_str)
        screen.hud_text(8,21,"F1: load different caveset")
        screen.hud_text(8,22,"F2: play demo (BD1 cave A)")
        screen.hud_text(8,23,"F3: show hall of fame")
        screen.hud_text(8,24,"F4: instructions")
        screen.hud_text(7,26,"Any joystick START button")
        screen.hud_text(10,27,"to start the game!")

        ; logo
        screen.show_logo_image(true)

        sub update_hud_choices_text() {
            cave_letter_str[len(cave_letter_str)-2] = chosen_level+'A'-1
            cave_difficulty_str[len(cave_difficulty_str)-2] = chosen_difficulty+'0'
        }
    }


    sub start_new_game() {
        cave.num_lives = 3
        cave.score = 0
        cave.score_500_for_bonus = 0
    }

    sub start_loaded_level() {
        cave.cover_all()
        cave.restart_level()
        main.start.title_timer = 250
        if quicklaunch_mode
            main.start.title_timer = 60
        game_state = STATE_CAVETITLE
        screen.hud_clear()
        screen.show_logo_image(false)
        screen.show_cave_title(true)
        screen.show_background_sprite_layer()
        screen.dim_covertile_color(false)
    }

    sub play_demo() {
        if bdcff.caveset_filename != BD1_CAVESET_FILE {
            ; demo only works on boulderdash 1 cave 1
            if not bdcff.load_caveset(BD1_CAVESET_FILE) or not bdcff.parse_caveset() {
                ; caveset load error
                error_abort($81)
            }
            highscore.load(BD1_CAVESET_FILE)
        }
        chosen_level = 1
        bdcff.parse_cave(1, chosen_difficulty)
        bd1demo.init()
        start_loaded_level()
        demo_requested = true
        main.start.title_timer = 1
    }

    sub show_instructions() {
        game_state = STATE_SHOWING_HISCORE
        main.start.display_hiscore_timer = INSTRUCTIONS_DISPLAY_TIME
        screen.hud_clear()
        screen.show_logo_image(false)
        screen.hud_text(7,3,"\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d")
        screen.hud_text(7,5,"Rock Runner  Instructions")
        screen.hud_text(7,7,"\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d")
        screen.hud_text(4,11,"Pick up enough diamonds in the")
        screen.hud_text(4,12,"cave to unlock the exit, and")
        screen.hud_text(4,13,"reach it before the time runs out.")
        screen.hud_text(4,14,"Avoid enemies and getting crushed.")
        screen.hud_text(4,17,"Control the game using any joypad")
        screen.hud_text(4,18,"(start button activates).")
        screen.hud_text(4,19,"Fire+direction lets you grab")
        screen.hud_text(4,20,"something without moving there!")
        screen.hud_text(4,23,"Press ESC when you're stuck: this")
        screen.hud_text(4,24,"restarts the level (losing a life)")

    }

    str caveset_prefix = "**"
    ubyte caveset_selected_index
    const ubyte CAVESET_DISPLAYLIST_MAXLENGTH = 20
    ubyte caveset_filenames_amount

    sub activate_select_caveset(ubyte prefixletter) {
        ; $81 = down, $82 = left, $83 = up, $84 = right arrows.
        game_state = STATE_SELECT_CAVESET
        screen.hud_clear()
        screen.show_logo_image(false)
        screen.hud_text(3,2,"Select a caveset from the list")
        screen.hud_text(3,3,"(scanned from the 'caves' subdir)")
        screen.hud_text(3,4,"Press letter or digit or '*' to use")
        screen.hud_text(3,5,"that as a name prefix filter.")
        diskio.chdir("caves")
        caveset_prefix[0] = prefixletter
        cx16.rambank(bdcff.FILENAMES_BANK)
        caveset_filenames_amount = diskio.list_filenames(caveset_prefix, $a000, $2000)
        diskio.chdir("..")
        ubyte row = 0
        uword name_ptr = $a000
        cx16.rambank(bdcff.FILENAMES_BANK)
        screen.hud_text(5, 13, "\x83")
        screen.hud_text(5, 22, "\x81")
        while row < CAVESET_DISPLAYLIST_MAXLENGTH and row < caveset_filenames_amount {
            screen.hud_text(12, row+8, name_ptr)
            row++
            while @(name_ptr)!=0
                name_ptr++
            name_ptr++
        }
        caveset_selected_index = 0
        screen.hud_text(9, 8, "\x84")       ; right arrow on the first entry
    }

    sub select_caveset() {
        ubyte keypress = cbm.GETIN2()
        while cbm.GETIN2()!=0 { /* clear keyboard buffer */ }
        cx16.r1L = strings.lowerchar(keypress)
        if cx16.r1L>32 and cx16.r1L<='z' {
            activate_select_caveset(cx16.r1L)
        } else {
            if keypress == 27 {
                activate_title_menu_state()
                return
            }
            if keypress==0 and interrupts.vsync_counter & 3 !=0
                return
            for joystick.active_joystick in 1 to 4 {        ; skip 0 as it interferes with the normal keys
                joystick.scan()
                if keypress==13 or joystick.start or joystick.fire {
                    if caveset_selected_index < caveset_filenames_amount {
                        uword name_ptr = $a000
                        cx16.rambank(bdcff.FILENAMES_BANK)
                        ubyte row=0
                        repeat {
                            if row==caveset_selected_index {
                                if name_ptr != "readme.txt" {
                                    if not bdcff.load_caveset(name_ptr) or not bdcff.parse_caveset() {
                                        ; caveset load error
                                        error_abort($84)
                                    }
                                    highscore.load(bdcff.caveset_filename)
                                    sys.wait(10)
                                    activate_title_menu_state()
                                }
                                return
                            }
                            row++
                            while @(name_ptr)!=0
                                name_ptr++
                            name_ptr++
                        }
                    }
                    return
                }
                if keypress==145 or joystick.up {
                    if caveset_selected_index>0 {
                        ; up
                        screen.hud_text(9, caveset_selected_index+8, " ")
                        caveset_selected_index--
                        screen.hud_text(9, caveset_selected_index+8, "\x84")       ; right arrow
                    }
                    return
                }
                if keypress==17 or joystick.down {
                    if caveset_selected_index<CAVESET_DISPLAYLIST_MAXLENGTH-1 {
                        ; down
                        screen.hud_text(9, caveset_selected_index+8, " ")
                        caveset_selected_index++
                        screen.hud_text(9, caveset_selected_index+8, "\x84")       ; right arrow
                    }
                    return
                }
            }
        }
    }

    sub show_hiscore() {
        game_state = STATE_SHOWING_HISCORE
        main.start.display_hiscore_timer = HISCORE_DISPLAY_TIME
        screen.hud_clear()
        screen.show_logo_image(false)
        screen.hud_text(7,3,"\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d")
        screen.hud_text(7,5,"Rock Runner  Hall Of Fame")
        screen.hud_text(7,6,"Caveset: ")
        screen.hud_text(16, 6, bdcff.caveset_filename)
        screen.hud_text(10, 7, bdcff.caveset_name)
        screen.hud_text(7,9,"\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d")
        ubyte position
        str position_str = "?."
        for position in 0 to 7 {
            position_str[0] = '1'+position
            screen.hud_text(10, 11+position*2, position_str)
            screen.hud_text(14, 11+position*2, highscore.get_name(position))
            uword score_string = conv.str_uw0(highscore.get_score(position))
            for cx16.r0L in 0 to 7 {
                if score_string[cx16.r0L] != '0'
                    break
                score_string[cx16.r0L] = ' '
            }
            screen.hud_text(24, 11+position*2, score_string)
        }
    }

    sub activate_highscore_enter_name() {
        game_state = STATE_ENTER_NAME
        music.init()
        music.playback_enabled = true
        screen.hud_clear()
        screen.hud_text(7,10,"\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d")
        screen.hud_text(7,12,"You got a new High Score!")
        screen.hud_text(7,14,"Enter your name:")
        screen.hud_text(7,16,"\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d\x88\x8d")
        highscore.start_enter_name()
        ; name entry is handled in a separate subroutine!
    }
}

screen {
    word scrollx
    word scrolly
    bool scrolling_into_view_x = false
    bool scrolling_into_view_y = false

    sub set_scroll_pos(uword sx, uword sy) {
        scrollx = sx as word
        scrolly = sy as word
    }

    ubyte old_vera_displaymode
    sub disable() {
        old_vera_displaymode = cx16.VERA_DC_VIDEO
        cx16.VERA_CTRL = 0
        cx16.VERA_DC_VIDEO &= %10001111
    }

    sub enable() {
        cx16.VERA_CTRL = 0
        cx16.VERA_DC_VIDEO = old_vera_displaymode
    }

    sub update() {
        ; set the tiles in video ram for the visible cells.
        ; cx16.vpoke(1,$fa00,$0f)
        ubyte row_offset = lsb(scrolly/16)
        ubyte col_offset = lsb(scrollx/16)
        ubyte @zp row
        for row in row_offset to row_offset+cave.VISIBLE_CELLS_V {
            cx16.vaddr(1, $b000 + row*$0080 + col_offset*2, 0, 1)
            uword cells_offset = row*cave.MAX_CAVE_WIDTH + col_offset
            uword @requirezp @shared cell_ptr = cave.cells + cells_offset
            uword @requirezp @shared attr_ptr = cave.cell_attributes + cells_offset
            %asm {{
                phx
                ldy  #0
_loop           lda  (p8v_attr_ptr),y
                and  #p8b_cave.p8c_ATTR_COVERED_FLAG
                beq  +
                ldx  #p8b_objects.p8c_covered
                bra  ++
+               lda  (p8v_cell_ptr),y
                tax
+               lda  p8b_objects.p8v_tile_lo,x
                clc
                adc  p8b_objects.p8v_anim_frame,x
                sta  cx16.VERA_DATA0
                lda  p8b_objects.p8v_tile_hi,x
                adc  p8b_objects.p8v_palette_offsets_preshifted,x
                sta  cx16.VERA_DATA0
                iny
                cpy  #p8b_cave.p8c_VISIBLE_CELLS_H+1
                bne  _loop
                plx
            }}
        }
        ; cx16.vpoke(1,$fa00,$00)
        screen.update_animations()
        if cave.scroll_enabled
            screen.update_scrollpos()
    }

    sub update_scrollpos() {
        ; try to recenter rockford in the visible screen
        word target_scrollx = (cave.player_x as word - cave.VISIBLE_CELLS_H/2) * 16
        word target_scrolly = (cave.player_y as word - cave.VISIBLE_CELLS_V/2) * 16
        word dx = target_scrollx - scrollx
        word dy = target_scrolly - scrolly
        if not scrolling_into_view_x {
            if abs(dx) < cave.VISIBLE_CELLS_H/4*16
                dx = 0
            else
                scrolling_into_view_x = true
        }
        if not scrolling_into_view_y {
            if abs(dy) < cave.VISIBLE_CELLS_V/4*16
                dy = 0
            else
                scrolling_into_view_y = true
        }

        scrolling_into_view_x = dx!=0
        scrolling_into_view_y = dy!=0
        if scrolling_into_view_x {
            dx >>= 5
            if dx==0
                scrollx++
            else
                scrollx += dx
        }
        if scrolling_into_view_y {
            dy >>= 5
            if dy==0
                scrolly++
            else
                scrolly += dy
        }
        scrollx = clamp(scrollx, 0, (cave.MAX_CAVE_WIDTH-cave.VISIBLE_CELLS_H)*16 as word)
        scrolly = clamp(scrolly, 0, (cave.MAX_CAVE_HEIGHT-cave.VISIBLE_CELLS_V)*16)
    }

    sub titlescreen() {
        ; 320x240 bitmap mode 4bpp (16 colors)
        cx16.VERA_CTRL = 0
        cx16.VERA_DC_BORDER = 0
        cx16.VERA_DC_VIDEO = cx16.VERA_DC_VIDEO & %10001111      ; no layers visible
        cx16.VERA_DC_HSCALE = 64
        cx16.VERA_DC_VSCALE = 64
        cx16.VERA_L0_CONFIG = %00000110
        cx16.VERA_L0_TILEBASE = 0

        void diskio.vload_raw("titlescreen.bin", 0, $0000)
        void diskio.vload_raw("titlescreen.pal", 1, $fa00)
        cx16.VERA_DC_VIDEO = cx16.VERA_DC_VIDEO | %00010000       ; layer 0 active
    }

    sub load_tiles() {
        void diskio.vload_raw("tiles.bin", 0, $0000)
        void diskio.vload_raw("tiles.pal", 1, $fa00)
        void diskio.vload_raw("font.bin", 1, $e000)
        ; fixup the palette for the HUD text font (entries $f0-$ff)
        cx16.vpoke(1,$fa00+$f0*2,$00)
        cx16.vpoke(1,$fa00+$f0*2+1,$00)
        cx16.vpoke(1,$fa00+$f1*2,$24)
        cx16.vpoke(1,$fa00+$f1*2+1,$05)
        cx16.vpoke(1,$fa00+$f2*2,$ff)
        cx16.vpoke(1,$fa00+$f2*2+1,$0f)
        cx16.vpoke(1,$fa00+$f2*3,$f0)
        cx16.vpoke(1,$fa00+$f2*3+1,$ff)

        void diskio.vload_raw("bgsprite.bin", 1, $f000)
        void diskio.vload_raw("bgsprite.pal", 1, $fa00+14*16*2)
        void diskio.vload_raw("logosprite.bin", 1, $d000)
        void diskio.vload_raw("titlescreen.pal", 1, $fa00+13*16*2)
    }

    sub update_animations() {
        ; increase anim delay counter of all animate objects
        ; once they reach their target, set it to 0 which will trigger the next animation tile in the sequence
        ; cx16.vpoke(1,$fa00,$f0)
        ubyte idx
        for idx in 0 to objects.NUM_OBJECTS-1 {
            if objects.anim_speeds[idx]!=0 {
                cx16.r0L = objects.anim_delay[idx]
                cx16.r0L++
                if cx16.r0L == objects.anim_speeds[idx] {
                    cx16.r0L = 0
                    cx16.r1L = objects.anim_frame[idx]
                    cx16.r1L++
                    if cx16.r1L == objects.anim_sizes[idx] {
                        if objects.attributes[idx] & objects.ATTRF_LOOPINGANIM !=0
                            cx16.r1L = 0
                        else
                            cx16.r1L--
                    }
                    objects.anim_frame[idx] = cx16.r1L
                }
                objects.anim_delay[idx] = cx16.r0L
            }
        }
        ; cx16.vpoke(1,$fa00,$00)
    }

    sub set_tiles_screenmode() {
        ; video setup:
        ; layer 0 = tile layer for the cave itself.
        ;           320x240 pixels, 4bpp (16 colors) 16x16 tiles.
        ;           tile map: 64x32 tiles at $1B000.
        ; layer 1 = tile layer for the text/HUD/score/time/etc.
        ;           320x240 pixels, 4bpp (16 colors) 16x16 tiles.
        ;           tile map: 64x32 tiles at $1C000.
        ;           uses font data at $1E000
        ; sprites background layer.

        ; pre-fill screen with space tiles
        cx16.vaddr(1, $b000, 0, 1)
        ubyte space_tile = objects.tile_lo[objects.space]
        repeat 64*32 {
            cx16.VERA_DATA0 = space_tile
            cx16.VERA_DATA0 = 0
        }
        hud_clear()

        cx16.VERA_CTRL = 0
        cx16.VERA_DC_BORDER = 0
        cx16.VERA_DC_VIDEO = cx16.VERA_DC_VIDEO & $0f | %01110000       ; layer 0 and 1 active, and sprites
        cx16.VERA_DC_HSCALE = 64
        cx16.VERA_DC_VSCALE = 64
        cx16.VERA_L0_CONFIG = %00010010                 ; 64x32 tiles, 4bpp
        cx16.VERA_L0_MAPBASE = ($1B000 >> 9) as ubyte
        cx16.VERA_L0_TILEBASE = %00000011               ; 16x16 pixel tiles
        cx16.VERA_L1_CONFIG = %00010001                 ; 64x32 tiles, 2bpp
        cx16.VERA_L1_MAPBASE = ($1C000 >> 9) as ubyte
        cx16.VERA_L1_TILEBASE = ($1E000 >>9) as ubyte | %00000000               ; 8x8 pixel tiles
    }

    sub hud_clear() {
        cx16.vaddr(1, $c000, 0, 1)
        repeat 64*32 {
            cx16.VERA_DATA0 = 32
            cx16.VERA_DATA0 = $f0
        }
    }

    sub hud_text(ubyte col, ubyte row, uword text_ptr) {
        uword offset = (row as uword) * 128 + col*2
        cx16.vaddr(1, $c000 + offset, 0, 1)
        repeat {
            cx16.r0L = @(text_ptr)
            if_z
                return
            cx16.VERA_DATA0 = cx16.r0L
            cx16.VERA_DATA0 = $f0  ; 'color'
            text_ptr++
        }
    }

    sub hud_wrap_text(ubyte col, ubyte row, ubyte maxwidth, uword text_ptr) {
        ubyte line_width
        row--
        new_line()
        repeat {
            ubyte word_length = next_word_length(text_ptr)
            if_z
                return
            repeat word_length {
                cx16.VERA_DATA0 = @(text_ptr)
                cx16.VERA_DATA0 = $f0 ; 'color'
                text_ptr++
                line_width++
            }
            cx16.VERA_DATA0 = ' '
            cx16.VERA_DATA0 = $f0 ; 'color'
            line_width++

            if @(text_ptr)==0
                return
            text_ptr++

            if line_width>maxwidth
                new_line()
        }

        sub new_line() {
            row++
            uword offset = (row as uword) * 128 + col*2
            cx16.vaddr(1, $c000 + offset, 0, 1)
            line_width = 0
        }

        sub next_word_length(uword txt) -> ubyte {
            ubyte length=0
            repeat {
                if @(txt)==0 or @(txt)==' '
                    return length
                length++
                txt++
            }
        }
    }

    sub hud_update() {
        const ubyte xpos = 8
        screen.hud_text(xpos+1, 1, "\x8e")     ; diamond symbol
        screen.hud_text(xpos+3, 1, conv.str_ub0(cave.num_diamonds))
        screen.hud_text(xpos+6, 1, "/")
        screen.hud_text(xpos+7, 1, conv.str_ub0(cave.diamonds_needed))
        screen.hud_text(xpos+12, 1, "\x88")       ; rockford symbol
        screen.hud_text(xpos+14, 1, conv.str_ub0(cave.num_lives))
        screen.hud_text(xpos+19, 1, "\x8f")     ; clock symbol
        screen.hud_text(xpos+21, 1, conv.str_ub0(cave.time_left_secs))
        screen.hud_text(xpos+26, 1, conv.str_uw0(cave.score))
    }

    sub show_cave_title(bool with_description) {
        const ubyte xpos = 3
        const ubyte ypos = 11
        screen.hud_text(xpos+4, ypos, "cave:")
        screen.hud_text(xpos+10, ypos, cave.name)
        if with_description
            screen.hud_wrap_text(xpos, ypos+3, 25, cave.description)
    }

    sub show_logo_image(bool visible) {
        ; the logo consists of two 64*64 sprites 4bpp

        cx16.VERA_CTRL = 0
        if visible {
            cx16.vaddr(1, $fc00, 0, 1)
            uword spr_xpos = 160-64
            uword spr_data = $1d000 >> 5
            repeat 2 {
                cx16.VERA_DATA0 = lsb(spr_data)
                cx16.VERA_DATA0 = msb(spr_data)
                cx16.VERA_DATA0 = lsb(spr_xpos)
                cx16.VERA_DATA0 = msb(spr_xpos)
                cx16.VERA_DATA0 = 80
                cx16.VERA_DATA0 = 0
                cx16.VERA_DATA0 = %00001100
                cx16.VERA_DATA0 = %11110000 | 13        ; palette offset 13 (14 is used by the stars backdrop, 15 by the text)
                spr_xpos += 64
                spr_data += 64
            }
            cx16.VERA_DC_VIDEO |= %01000000
        }
        else
            cx16.VERA_DC_VIDEO &= %10111111
    }

    sub show_background_sprite_layer() {
        ; background sprite layer: repeat a big sprite a couple of times across the background.
        cx16.vaddr(1, $fc00, 0, 1)
        ubyte spr_ypos = 0
        repeat 4 {
            ubyte spr_xpos = 8
            repeat 4 {
                cx16.VERA_DATA0 = lsb($1f000 >> 5)
                cx16.VERA_DATA0 = lsb($1f000 >> 13)
                cx16.VERA_DATA0 = spr_xpos
                cx16.VERA_DATA0 = 0
                cx16.VERA_DATA0 = spr_ypos
                cx16.VERA_DATA0 = 0
                cx16.VERA_DATA0 = %00000100
                cx16.VERA_DATA0 = %11110000 | 14
                spr_xpos += 80
                spr_ypos += 8
            }
            spr_ypos += 80-32
        }

        cx16.VERA_DC_VIDEO |= %01000000
    }

    bool white_flash
    ubyte[16*4] palette_save

    sub flash_white(bool white) {
        white_flash = white
        ubyte idx=0
        uword pal = $fa00
        if white {
            repeat 16 {
                palette_save[idx] = cx16.vpeek(1,pal)
                idx++
                cx16.vpoke(1,pal,$ff)
                pal++
                palette_save[idx] = cx16.vpeek(1,pal)
                idx++
                cx16.vpoke(1,pal,$0f)
                pal++
                palette_save[idx] = cx16.vpeek(1,pal)
                idx++
                cx16.vpoke(1,pal,$ff)
                pal++
                palette_save[idx] = cx16.vpeek(1,pal)
                idx++
                cx16.vpoke(1,pal,$0f)
                pal+=29
            }
        } else {
            repeat 16 {
                cx16.vpoke(1,pal,palette_save[idx])
                idx++
                pal++
                cx16.vpoke(1,pal,palette_save[idx])
                idx++
                pal++
                cx16.vpoke(1,pal,palette_save[idx])
                idx++
                pal++
                cx16.vpoke(1,pal,palette_save[idx])
                idx++
                pal+=29
            }
        }
    }

    uword[16] orig_covertile_colors
    bool already_dimmed
    sub dim_covertile_color(bool dim) {
        ; This makes the cover tile colors darker (or resets them back to the originals),
        ; it is used on the title screens to make the text more readable.

        if dim and already_dimmed
            return      ; don't dim twice

        uword palette_idx = $fa00 + objects.palette_offsets_preshifted[objects.covered]*$0002

        if not already_dimmed {
            ; backup the original covertile color entries
            cx16.vaddr(1, palette_idx, 0, 1)
            for cx16.r0L in 0 to 15 {
                cx16.r1 = mkword(cx16.VERA_DATA0, cx16.VERA_DATA0)
                orig_covertile_colors[cx16.r0L] = cx16.r1
            }
        }

        cx16.vaddr(1, palette_idx, 0, 1)
        if dim {
            for cx16.r0L in 0 to 15 {
                cx16.r1 = orig_covertile_colors[cx16.r0L]
                cx16.VERA_DATA0 = (lsb(cx16.r1) >> 1) & %01110111
                cx16.VERA_DATA0 = msb(cx16.r1)>>1
            }
        } else {
            for cx16.r0L in 0 to 15 {
                cx16.r1 = orig_covertile_colors[cx16.r0L]
                cx16.VERA_DATA0 = lsb(cx16.r1)
                cx16.VERA_DATA0 = msb(cx16.r1)
            }
        }
        already_dimmed = dim
    }
}

interrupts {
    ubyte vsync_counter = 0
    ubyte cavescan_frame = 0
    ubyte vsync_semaphore = 1
    ubyte ram_bank
    ubyte ram_bank_backup

    asmsub waitvsync() {
        ; an improved waitvsync() routine over the one in the sys lib
        %asm {{
-           wai
            lda  p8v_vsync_semaphore
            bne  -
            inc  p8v_vsync_semaphore
            rts
        }}
    }

    sub handler() -> bool {
        if cx16.VERA_ISR & %00000001 !=0 {
            ram_bank_backup = cx16.getrambank()
            cx16.rambank(ram_bank)       ; make sure we see the correct ram bank
            cx16.save_virtual_registers()
            vsync_semaphore=0
            vsync_counter++
            cavescan_frame++
            cx16.save_vera_context()
            set_softscroll()             ; soft-scrolling is handled in this irq handler itself to avoid stutters and tearing
            music.update()
            cave.do_each_frame()         ; for timing critical stuff
            cx16.restore_vera_context()
            void psg.envelopes_irq()          ; note: does its own vera save/restore context
            cx16.rambank(ram_bank_backup)
            cx16.restore_virtual_registers()
            return true
        }
        return false
    }

    sub set_softscroll() {
        ; smooth scroll the cave layer to top left pixel at sx, sy
        cx16.VERA_L0_HSCROLL_H = msb(screen.scrollx)
        cx16.VERA_L0_HSCROLL_L = lsb(screen.scrollx)
        cx16.VERA_L0_VSCROLL_H = msb(screen.scrolly)
        cx16.VERA_L0_VSCROLL_L = lsb(screen.scrolly)
    }
}
